\documentclass[12pt]{article}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{enumerate}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\def\code#1{\texttt{#1}}
\title{Kompresja danych - projekt 1}
\date{\today}
\author{Bartosz Matyjasiak}

\begin{document}
\maketitle
\tableofcontents
\pagebreak


\section{Wstęp}
Dany jest główny plik muzyczny (znany już z poprzednich sesji laboratoryjnych)
\code{music2.wav} oraz dwa pliki pomocnicze (\code{song.wav} i \code{icing.wav}).

Zaproponuj metodę kwantyzacji, a następnie kodowania, która w możliwie
najlepszy sposób kompresuje główny plik muzyczny. Kompresja powinna spełnić
następujące warunki:
\begin{enumerate}[I]
  \item Niemożliwe (lub bardzo trudne) do usłyszenia różnice między muzyką odtworzoną z pliku oryginalnego i pliku skompresowanego.
  \item Wartość PSNR (szczytowy stosunek sygnału szczytowego do szumu) nie mniejsza niż 40dB.
  \item Możliwie najmniejsza wartość średniej bitowej BR.
\end{enumerate}

Fizyczne zakodowanie pliku (tzn. utworzenie ciągu bitowego) nie jest konieczne, ale dane wyjściowe powinny być uzyskane w taki sposób, jakby rzeczywiście zostały odtworzone na podstawie ciągu bitowego.

Przetestuj zaproponowaną metodę (używając dokładnie tych samych parametrów) na dwóch plikach pomocniczych. Czy uzyskane wyniki są podobne, a
jeśli nie, to jakie zmiany proponujesz?


\section{Opis rozwiązania}\label{about}
\subsection{Kwantyzacja}
Po wczytaniu pliku oraz doprowadzeniu do postaci gdzie każdy komunikat jest reprezentowany przez liczbę zmiennoprzecinkową z zakresu $[-1;1]$
dokonałem kwantyzacji wektorowej (tu ponieważ, że pliki muzyczne są jednokanałowe to wektory są jednowymiarowe) przy użyciu klasteryzacji.

Metoda ta polega na wybraniu losowych L centroidów. Następnie sygnały klasyfikujemy wg. najmniejszej odległości.
Kolejnie dla każdej z klas wyliczamy średnią i ją traktujemy jako nowy centroid. Kroki te wykonujemy wielokrotnie lub do momentu gdy centroidy nie zmienią się w kolejnej iteracji. 

\subsection{Kodowanie}
Sygnał skwantowany zakodowałem kodem Huffmana. Kodowanie to opiera sie na znanym prawdopodobieństwu wystąpienia poszczególnych komunikatów ze źródła.

W sygnale skończonym takim jak plik audio oszacowanie ich jest bardzo proste. Wystarczy policzyć wystąpienia każdego z komunikatów i podzielić przez ilość wszystkich komunikatów w sygnale.
Po użyciu biblioteki \code{huffman} i otrzymaniu słów kodowych wyliczyłem średnią długość słowa kodowego w pliku, entropie oraz efektywność kodowania.

\section{Uruchomienie projektu}

Do rozwiązania wykorzystałem język programowania Python w wersji 3.9.0 64bit.
Przed uruchomienień należy też zainstalować pakiety: \code{scipy numpy huffman sounddevice}.
By uruchomić projekt należy uruchomić plik \code{main.py} w środowisku Python.

Przykładowe zainstalowanie wymaganych pakietów oraz uruchomienie projektu w konsoli Windows:
\begin{lstlisting}[language=bash]
  pip install scipy numpy sounddevice huffman
  python main.py
\end{lstlisting}
Skrypt dla każdego z plików muzycznych wykonuje:
\begin{enumerate}
  \item kwantyzacje dla małej ilości poziomów kwantyzacji,
  \item kodowanie Huffmana,
  \item wylicza i wypisuje dane statystyczne (PSNR, entropia, średnia bitowa, efektywność kodu),
  \item zapisuje plik wynikowy \code{wav} do folderu \code{output} (w razie chęci odsłuchania w innym programie),
  \item odtwarzanie wyniku kompresji.
\end{enumerate}
W funkcji \code{main()} można dostosować ilość poziomów kwantyzacji poprzez zmiane zmiennej \code{bits} ($L=2^{bits}$).

\section{Wyniki}\label{results}
Po uruchomieniu programu otrzymałem wynik programu (dla 32 poziomów kwantyzacji):
\verbatiminput{raportlast.txt}
Wszystkie pliki mają zblizoną wartość PSNR do 40, a średnia długość bitowa nie przekracza 5 bitów.
Na tym poziomie kwantyzacji szum jest słyszalny w tle.

Po zwiekszeniu poziomów kwantyzacji do 64 szum z tła został zredukowany,
lecz dalej słychać małe trzaski w niektórych miejscach w wszystkich trzech plikach.

Dopiero dla 256 poziomów kwantyzacji program dawał rezultat bliski trudnemu odróżnieniu sygnału oryginalnego od skompresowanego.
Wynik dla 256 poziomów kwantyzacji.
\verbatiminput{raportlast3.txt}

Można też zauważyć, że kodowanie Huffmana swietnie się sprawdziło w obydwu powyższych scenariuszach nie schodząć poniżej 99\% efektywności.

\end{document}